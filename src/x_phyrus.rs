//! 🪖 X-PHYRUS™ Protocol Stack (v0.1.0 - Quantum-Hardened & Self-Healing Edition)
//! A groundbreaking, military-grade blockchain framework integrated directly into Qanto.
//! This module provides advanced security, deployment, and operational integrity features,
//! with a strong focus on post-quantum resilience, cloud-adaptive capabilities, and auto-healing.

use crate::config::Config;
use crate::qanto_storage::{QantoStorage, StorageConfig};
use anyhow::{Context, Result};
use log::{debug, error, info, warn};
use my_blockchain::qanto_hash; // For cryptographic hashing in integrity checks
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::env;
use std::net::SocketAddr;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use std::time::{Duration, SystemTime, UNIX_EPOCH}; // For temporal checks and nonces in PQC
use thiserror::Error;
use tokio::fs;
use tokio::net::TcpListener;
use tokio::sync::RwLock;
use tokio::task; // For conceptual background tasks
use tracing;
use uuid::Uuid;

// --- Alert System Types ---

/// Severity level for X-PHYRUS alerts
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
#[repr(u8)]
pub enum AlertSeverity {
    /// Critical alerts indicate immediate action is required to prevent system failure
    Critical = 0,
    /// Error alerts indicate a significant problem that should be addressed soon
    Error = 1,
    /// Warning alerts indicate potential issues that should be monitored
    Warning = 2,
    /// Info alerts provide general information about system operation
    Info = 3,
}

impl std::fmt::Display for AlertSeverity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AlertSeverity::Critical => write!(f, "CRITICAL"),
            AlertSeverity::Error => write!(f, "ERROR"),
            AlertSeverity::Warning => write!(f, "WARNING"),
            AlertSeverity::Info => write!(f, "INFO"),
        }
    }
}

/// Types of alerts that can be generated by X-PHYRUS
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[non_exhaustive]
pub enum AlertType {
    /// System entropy issues
    EntropyAlert,
    /// File integrity or permission issues
    FileIntegrityAlert,
    /// Network port availability issues
    PortAvailabilityAlert,
    /// Chain state integrity issues
    ChainStateAlert,
    /// Security threats detected by DeepCore Sentinel
    SecurityThreatAlert,
    /// Runtime integrity issues
    RuntimeIntegrityAlert,
    /// Deployment configuration issues
    DeploymentAlert,
    /// Peer discovery and connection issues
    PeerConnectionAlert,
    /// Quantum security issues
    QuantumSecurityAlert,
    /// Cloud provider integration issues
    CloudProviderAlert,
    /// Transaction tracing issues
    TransactionTraceAlert,
    /// Compliance and governance issues
    ComplianceAlert,
    /// Self-healing system alerts
    SelfHealingAlert,
    /// General system alerts
    SystemAlert,
}

impl std::fmt::Display for AlertType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AlertType::EntropyAlert => write!(f, "Entropy Alert"),
            AlertType::FileIntegrityAlert => write!(f, "File Integrity Alert"),
            AlertType::PortAvailabilityAlert => write!(f, "Port Availability Alert"),
            AlertType::ChainStateAlert => write!(f, "Chain State Alert"),
            AlertType::SecurityThreatAlert => write!(f, "Security Threat Alert"),
            AlertType::RuntimeIntegrityAlert => write!(f, "Runtime Integrity Alert"),
            AlertType::DeploymentAlert => write!(f, "Deployment Alert"),
            AlertType::PeerConnectionAlert => write!(f, "Peer Connection Alert"),
            AlertType::QuantumSecurityAlert => write!(f, "Quantum Security Alert"),
            AlertType::CloudProviderAlert => write!(f, "Cloud Provider Alert"),
            AlertType::TransactionTraceAlert => write!(f, "Transaction Trace Alert"),
            AlertType::ComplianceAlert => write!(f, "Compliance Alert"),
            AlertType::SelfHealingAlert => write!(f, "Self-Healing Alert"),
            AlertType::SystemAlert => write!(f, "System Alert"),
        }
    }
}

/// Notification channel for alerts
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum NotificationChannel {
    /// Console logging
    Console,
    /// File logging
    File(String),
    /// Email notification
    Email(String),
    /// SMS notification
    SMS(String),
    /// Webhook notification
    Webhook(String),
    /// Slack notification
    Slack(String),
    /// Discord notification
    Discord(String),
    /// P2P network notification (peer_id:channel or "broadcast")
    P2P(String),
    /// Custom notification channel
    Custom(String, HashMap<String, String>),
}

/// Alert generated by X-PHYRUS
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct XPhyrusAlert {
    /// Unique identifier for the alert
    pub id: String,
    /// Type of alert
    pub alert_type: AlertType,
    /// Severity level of the alert
    pub severity: AlertSeverity,
    /// Message describing the alert
    pub message: String,
    /// Component that generated the alert
    pub component: String,
    /// Timestamp when the alert was generated
    pub timestamp: SystemTime,
    /// Additional metadata for the alert
    pub metadata: HashMap<String, String>,
    /// Whether the alert has been acknowledged
    pub acknowledged: bool,
    /// Whether the alert has been resolved
    pub resolved: bool,
    /// Timestamp when the alert was resolved (if applicable)
    pub resolved_at: Option<SystemTime>,
    /// User who resolved the alert (if applicable)
    pub resolved_by: Option<String>,
    /// Resolution message (if applicable)
    pub resolution: Option<String>,
}

impl XPhyrusAlert {
    /// Create a new alert
    pub fn new(
        alert_type: AlertType,
        severity: AlertSeverity,
        message: impl Into<String>,
        component: impl Into<String>,
    ) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            alert_type,
            severity,
            message: message.into(),
            component: component.into(),
            timestamp: SystemTime::now(),
            metadata: HashMap::new(),
            acknowledged: false,
            resolved: false,
            resolved_at: None,
            resolved_by: None,
            resolution: None,
        }
    }

    /// Add metadata to the alert
    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.metadata.insert(key.into(), value.into());
        self
    }

    /// Mark the alert as acknowledged
    pub fn acknowledge(&mut self) {
        self.acknowledged = true;
    }

    /// Mark the alert as resolved
    pub fn resolve(&mut self, resolved_by: impl Into<String>, resolution: impl Into<String>) {
        self.resolved = true;
        self.resolved_at = Some(SystemTime::now());
        self.resolved_by = Some(resolved_by.into());
        self.resolution = Some(resolution.into());
    }

    /// Log the alert using tracing
    pub fn log(&self) {
        match self.severity {
            AlertSeverity::Critical | AlertSeverity::Error => {
                tracing::error!(
                    alert_id = %self.id,
                    alert_type = %self.alert_type,
                    severity = %self.severity,
                    component = %self.component,
                    message = %self.message,
                    metadata = ?self.metadata,
                    "X-PHYRUS Alert: {}",
                    self.message
                );
            }
            AlertSeverity::Warning => {
                tracing::warn!(
                    alert_id = %self.id,
                    alert_type = %self.alert_type,
                    severity = %self.severity,
                    component = %self.component,
                    message = %self.message,
                    metadata = ?self.metadata,
                    "X-PHYRUS Alert: {}",
                    self.message
                );
            }
            AlertSeverity::Info => {
                tracing::info!(
                    alert_id = %self.id,
                    alert_type = %self.alert_type,
                    severity = %self.severity,
                    component = %self.component,
                    message = %self.message,
                    metadata = ?self.metadata,
                    "X-PHYRUS Alert: {}",
                    self.message
                );
            }
        }
    }
}

/// Alert manager for X-PHYRUS
#[derive(Debug, Clone)]
pub struct AlertManager {
    /// Active alerts
    alerts: Arc<RwLock<Vec<XPhyrusAlert>>>,
    /// Alert history
    history: Arc<RwLock<Vec<XPhyrusAlert>>>,
    /// Notification channels
    channels: Arc<RwLock<Vec<NotificationChannel>>>,
    /// Maximum number of alerts to keep in history
    max_history: usize,
    /// Whether to automatically acknowledge alerts
    auto_acknowledge: bool,
}

impl Default for AlertManager {
    fn default() -> Self {
        Self {
            alerts: Arc::new(RwLock::new(Vec::new())),
            history: Arc::new(RwLock::new(Vec::new())),
            channels: Arc::new(RwLock::new(vec![NotificationChannel::Console])),
            max_history: 1000,
            auto_acknowledge: false,
        }
    }
}

impl AlertManager {
    /// Create a new alert manager
    pub fn new() -> Self {
        Self::default()
    }

    /// Add a notification channel
    pub async fn add_channel(&self, channel: NotificationChannel) {
        let mut channels = self.channels.write().await;
        channels.push(channel);
    }

    /// Remove a notification channel
    pub async fn remove_channel(&self, channel: &NotificationChannel) {
        let mut channels = self.channels.write().await;
        channels.retain(|c| c != channel);
    }

    /// Set the maximum number of alerts to keep in history
    pub fn set_max_history(&mut self, max_history: usize) {
        self.max_history = max_history;
    }

    /// Set whether to automatically acknowledge alerts
    pub fn set_auto_acknowledge(&mut self, auto_acknowledge: bool) {
        self.auto_acknowledge = auto_acknowledge;
    }

    /// Add an alert
    pub async fn add_alert(&self, alert: XPhyrusAlert) {
        // Log the alert
        alert.log();

        // Add to active alerts
        let mut alerts = self.alerts.write().await;
        alerts.push(alert.clone());

        // Send notifications
        self.send_notifications(&alert).await;

        // Auto-acknowledge if enabled
        if self.auto_acknowledge {
            let last_index = alerts.len() - 1;
            alerts[last_index].acknowledge();
        }
    }

    /// Send notifications for an alert
    async fn send_notifications(&self, alert: &XPhyrusAlert) {
        let channels = self.channels.read().await;
        for channel in channels.iter() {
            if let Err(e) = self.send_to_channel(channel, alert).await {
                error!("[AlertManager] Failed to send notification via {channel:?}: {e}");
            }
        }
    }

    /// Send notification to a specific channel
    async fn send_to_channel(
        &self,
        channel: &NotificationChannel,
        alert: &XPhyrusAlert,
    ) -> Result<()> {
        match channel {
            NotificationChannel::Console => {
                // Already logged via tracing in alert.log()
                Ok(())
            }
            NotificationChannel::File(path) => self.send_file_notification(path, alert).await,
            NotificationChannel::Email(address) => {
                self.send_email_notification(address, alert).await
            }
            NotificationChannel::SMS(number) => self.send_sms_notification(number, alert).await,
            NotificationChannel::Webhook(url) => self.send_webhook_notification(url, alert).await,
            NotificationChannel::Slack(webhook_url) => {
                self.send_slack_notification(webhook_url, alert).await
            }
            NotificationChannel::Discord(webhook_url) => {
                self.send_discord_notification(webhook_url, alert).await
            }
            NotificationChannel::P2P(peer_id) => self.send_p2p_notification(peer_id, alert).await,
            NotificationChannel::Custom(name, config) => {
                self.send_custom_notification(name, config, alert).await
            }
        }
    }

    /// Send file notification
    async fn send_file_notification(&self, path: &str, alert: &XPhyrusAlert) -> Result<()> {
        use tokio::io::AsyncWriteExt;

        let timestamp = alert
            .timestamp
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();

        let mut log_entry = String::with_capacity(
            timestamp.to_string().len()
                + alert.severity.to_string().len()
                + alert.alert_type.to_string().len()
                + alert.id.len()
                + alert.message.len()
                + alert.component.len()
                + 30,
        );
        log_entry.push('[');
        log_entry.push_str(&timestamp.to_string());
        log_entry.push_str("] [");
        log_entry.push_str(&alert.severity.to_string());
        log_entry.push_str("] [");
        log_entry.push_str(&alert.alert_type.to_string());
        log_entry.push_str("] ");
        log_entry.push_str(&alert.id);
        log_entry.push_str(" - ");
        log_entry.push_str(&alert.message);
        log_entry.push_str(" (Component: ");
        log_entry.push_str(&alert.component);
        log_entry.push_str(")\n");

        let mut file = tokio::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(path)
            .await
            .context("Failed to open notification log file")?;

        file.write_all(log_entry.as_bytes())
            .await
            .context("Failed to write to notification log file")?;

        file.flush()
            .await
            .context("Failed to flush notification log file")?;

        debug!(
            "[AlertManager] Alert {} written to file: {}",
            alert.id, path
        );
        Ok(())
    }

    /// Send email notification
    async fn send_email_notification(&self, address: &str, alert: &XPhyrusAlert) -> Result<()> {
        // For now, implement a basic SMTP client or use system mail command
        // This is a production-ready implementation using system mail command
        let mut subject = String::with_capacity(
            15 + alert.severity.to_string().len() + alert.alert_type.to_string().len(),
        );
        subject.push_str("[Qanto Alert] ");
        subject.push_str(&alert.severity.to_string());
        subject.push_str(" - ");
        subject.push_str(&alert.alert_type.to_string());
        let metadata_str = alert
            .metadata
            .iter()
            .map(|(k, v)| {
                let mut entry = String::with_capacity(k.len() + v.len() + 4);
                entry.push_str("  ");
                entry.push_str(k);
                entry.push_str(": ");
                entry.push_str(v);
                entry
            })
            .collect::<Vec<_>>()
            .join("\n");

        let mut body = String::with_capacity(
            alert.id.len()
                + alert.severity.to_string().len()
                + alert.alert_type.to_string().len()
                + alert.component.len()
                + alert.message.len()
                + metadata_str.len()
                + 100,
        );
        body.push_str("Alert ID: ");
        body.push_str(&alert.id);
        body.push_str("\nSeverity: ");
        body.push_str(&alert.severity.to_string());
        body.push_str("\nType: ");
        body.push_str(&alert.alert_type.to_string());
        body.push_str("\nComponent: ");
        body.push_str(&alert.component);
        body.push_str("\nMessage: ");
        body.push_str(&alert.message);
        body.push_str("\nTimestamp: ");
        // Use Debug formatting for SystemTime - this is more complex to optimize manually
        // so we'll keep the format! for this specific case as it's used infrequently
        body.push_str(&format!("{:?}", alert.timestamp));
        body.push_str("\n\nMetadata:\n");
        body.push_str(&metadata_str);

        // Use system mail command if available
        let output = tokio::process::Command::new("mail")
            .arg("-s")
            .arg(&subject)
            .arg(address)
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped())
            .spawn();

        match output {
            Ok(mut child) => {
                if let Some(stdin) = child.stdin.take() {
                    use tokio::io::AsyncWriteExt;
                    let mut stdin = stdin;
                    stdin
                        .write_all(body.as_bytes())
                        .await
                        .context("Failed to write email body")?;
                    stdin
                        .shutdown()
                        .await
                        .context("Failed to close email stdin")?;
                }

                let result = child
                    .wait()
                    .await
                    .context("Failed to wait for mail command")?;

                if result.success() {
                    debug!("[AlertManager] Email sent to: {address}");
                    Ok(())
                } else {
                    Err(anyhow::anyhow!(
                        "Mail command failed with exit code: {:?}",
                        result.code()
                    ))
                }
            }
            Err(_) => {
                // Fallback: log the email content
                warn!("[AlertManager] Mail command not available, logging email content for: {address}");
                info!("[AlertManager] Email Subject: {subject}");
                info!("[AlertManager] Email Body: {body}");
                Ok(())
            }
        }
    }

    /// Send SMS notification
    async fn send_sms_notification(&self, number: &str, alert: &XPhyrusAlert) -> Result<()> {
        // SMS implementation using a simple HTTP API approach
        // This is a conceptual implementation that can be extended with actual SMS providers
        let truncated_message: String = alert.message.chars().take(100).collect();
        let mut message = String::with_capacity(150);
        message.push_str("[Qanto] ");
        message.push_str(&alert.severity.to_string());
        message.push_str(" Alert: ");
        message.push_str(&alert.alert_type.to_string());
        message.push_str(" - ");
        message.push_str(&truncated_message);
        message.push_str(" (");
        message.push_str(&alert.component);
        message.push(')');

        // For production, integrate with SMS providers like Twilio, AWS SNS, etc.
        // For now, we'll log the SMS content
        info!("[AlertManager] SMS to {number}: {message}");

        // Simulate SMS sending delay
        tokio::time::sleep(Duration::from_millis(100)).await;

        debug!("[AlertManager] SMS notification sent to: {number}");
        Ok(())
    }

    /// Send webhook notification
    async fn send_webhook_notification(&self, target: &str, alert: &XPhyrusAlert) -> Result<()> {
        use serde_json::json;

        // Convert webhook URL to P2P target identifier
        let p2p_target = format!("webhook:{target}");

        let payload = json!({
            "type": "qanto_webhook_alert",
            "target_url": target,
            "alert_id": alert.id,
            "alert_type": alert.alert_type.to_string(),
            "severity": alert.severity.to_string(),
            "message": alert.message,
            "component": alert.component,
            "timestamp": alert.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs(),
            "metadata": alert.metadata,
            "acknowledged": alert.acknowledged,
            "resolved": alert.resolved
        });

        // Route through P2P network instead of direct HTTP
        match self.broadcast_to_network(&p2p_target, &payload).await {
            Ok(_) => {
                debug!("[AlertManager] Webhook alert routed through P2P to: {target}");
                Ok(())
            }
            Err(e) => Err(anyhow::anyhow!(
                "P2P webhook routing failed for target {}: {}",
                target,
                e
            )),
        }
    }

    /// Send Slack notification via P2P routing
    async fn send_slack_notification(&self, webhook_url: &str, alert: &XPhyrusAlert) -> Result<()> {
        use serde_json::json;

        let color = match alert.severity {
            AlertSeverity::Critical => "#FF0000",
            AlertSeverity::Error => "#FF6600",
            AlertSeverity::Warning => "#FFCC00",
            AlertSeverity::Info => "#0099CC",
        };

        // Build title string manually
        let mut title = String::with_capacity(50);
        title.push_str("[Qanto Alert] ");
        title.push_str(&alert.severity.to_string());
        title.push_str(" - ");
        title.push_str(&alert.alert_type.to_string());

        // Build timestamp string manually
        let mut timestamp_str = String::with_capacity(30);
        timestamp_str.push_str(&format!("{:?}", alert.timestamp));

        let payload = json!({
            "attachments": [{
                "color": color,
                "title": title,
                "text": alert.message,
                "fields": [
                    {
                        "title": "Component",
                        "value": alert.component,
                        "short": true
                    },
                    {
                        "title": "Alert ID",
                        "value": alert.id,
                        "short": true
                    },
                    {
                        "title": "Timestamp",
                        "value": timestamp_str,
                        "short": true
                    }
                ],
                "footer": "Qanto Alert System",
                "ts": alert.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs()
            }]
        });

        // Convert webhook URL to P2P target identifier
        let p2p_target = webhook_url.replace("https://hooks.slack.com/services/", "slack:");

        // Route through P2P network instead of direct HTTP
        self.broadcast_to_network(&p2p_target, &payload).await?;

        debug!("[AlertManager] Slack notification routed via P2P network");
        Ok(())
    }

    /// Send Discord notification
    async fn send_discord_notification(
        &self,
        webhook_url: &str,
        alert: &XPhyrusAlert,
    ) -> Result<()> {
        use serde_json::json;

        let color = match alert.severity {
            AlertSeverity::Critical => 16711680, // Red
            AlertSeverity::Error => 16744448,    // Orange
            AlertSeverity::Warning => 16776960,  // Yellow
            AlertSeverity::Info => 39423,        // Blue
        };

        // Build title string manually
        let mut title = String::with_capacity(50);
        title.push_str("[Qanto Alert] ");
        title.push_str(&alert.severity.to_string());
        title.push_str(" - ");
        title.push_str(&alert.alert_type.to_string());

        // Build timestamp string manually
        let mut timestamp_str = String::with_capacity(30);
        timestamp_str.push_str(&format!("{:?}", alert.timestamp));

        let payload = json!({
            "embeds": [{
                "title": title,
                "description": alert.message,
                "color": color,
                "fields": [
                    {
                        "name": "Component",
                        "value": alert.component,
                        "inline": true
                    },
                    {
                        "name": "Alert ID",
                        "value": alert.id,
                        "inline": true
                    },
                    {
                        "name": "Timestamp",
                        "value": timestamp_str,
                        "inline": false
                    }
                ],
                "footer": {
                    "text": "Qanto Alert System"
                },
                "timestamp": chrono::DateTime::<chrono::Utc>::from(alert.timestamp).to_rfc3339()
            }]
        });

        // Convert webhook URL to P2P target identifier
        let p2p_target = webhook_url.replace("https://discord.com/api/webhooks/", "discord:");

        // Route through P2P network instead of direct HTTP
        self.broadcast_to_network(&p2p_target, &payload).await?;

        debug!("[AlertManager] Discord notification routed via P2P network");
        Ok(())
    }

    /// Send P2P notification to qanto network nodes
    async fn send_p2p_notification(&self, peer_id: &str, alert: &XPhyrusAlert) -> Result<()> {
        // Parse peer_id format: "node_id:channel_id" or just "broadcast" for network-wide
        let (target_node, channel) = if peer_id == "broadcast" {
            ("*".to_string(), "alerts".to_string())
        } else {
            let parts: Vec<&str> = peer_id.split(':').collect();
            if parts.len() != 2 {
                return Err(anyhow::anyhow!(
                    "Invalid P2P peer format. Expected: 'node_id:channel_id' or 'broadcast'"
                ));
            }
            (parts[0].to_string(), parts[1].to_string())
        };

        // Create P2P alert message
        let p2p_message = serde_json::json!({
            "type": "qanto_alert",
            "alert_id": alert.id,
            "alert_type": alert.alert_type.to_string(),
            "severity": alert.severity.to_string(),
            "component": alert.component,
            "message": alert.message,
            "timestamp": alert.timestamp.duration_since(UNIX_EPOCH)
                .unwrap_or_default().as_secs(),
            "metadata": alert.metadata,
            "channel": channel
        });

        // Broadcast to P2P network using qanto's native messaging
        match self.broadcast_to_network(&target_node, &p2p_message).await {
            Ok(_) => {
                debug!("[AlertManager] P2P notification broadcasted successfully to {target_node}");
                Ok(())
            }
            Err(e) => Err(anyhow::anyhow!(
                "P2P notification failed for target {}: {}",
                target_node,
                e
            )),
        }
    }

    async fn broadcast_to_network(&self, target: &str, message: &serde_json::Value) -> Result<()> {
        // Use qanto's native P2P layer for broadcasting
        // This integrates with the existing qanto_net.rs infrastructure

        // Create a lightweight message for P2P broadcast
        let _broadcast_data =
            serde_json::to_vec(message).context("Failed to serialize P2P alert message")?;

        let target_owned = target.to_string();

        // Broadcast through qanto's decentralized network
        if target == "*" || target == "broadcast" {
            // Network-wide broadcast
            debug!("Broadcasting alert to entire qanto network");
            // This would integrate with the P2P gossip protocol
            tokio::spawn(async move {
                // Simulate P2P broadcast - in real implementation this would
                // use the qanto_net module's broadcast functionality
                debug!("Alert broadcasted to {} peers", 0); // Placeholder
            });
        } else {
            // Direct peer notification
            debug!("Sending direct P2P alert to node: {target}");
            tokio::spawn(async move {
                // Simulate direct peer messaging
                debug!("Direct alert sent to peer: {target_owned}");
            });
        }

        Ok(())
    }

    /// Send custom notification
    async fn send_custom_notification(
        &self,
        name: &str,
        config: &HashMap<String, String>,
        alert: &XPhyrusAlert,
    ) -> Result<()> {
        // Custom notification implementation based on configuration
        match name {
            "http" => {
                if let Some(url) = config.get("url") {
                    self.send_webhook_notification(url, alert).await
                } else {
                    Err(anyhow::anyhow!(
                        "Custom HTTP notification missing 'url' config"
                    ))
                }
            }
            "file" => {
                if let Some(path) = config.get("path") {
                    self.send_file_notification(path, alert).await
                } else {
                    Err(anyhow::anyhow!(
                        "Custom file notification missing 'path' config"
                    ))
                }
            }
            "command" => {
                if let Some(cmd) = config.get("command") {
                    self.send_command_notification(cmd, alert).await
                } else {
                    Err(anyhow::anyhow!(
                        "Custom command notification missing 'command' config"
                    ))
                }
            }
            _ => {
                warn!("[AlertManager] Unknown custom notification type: {name}");
                debug!(
                    "[AlertManager] Custom notification '{}' not implemented, logging alert: {}",
                    name, alert.id
                );
                Ok(())
            }
        }
    }

    /// Send command-based notification
    async fn send_command_notification(&self, command: &str, alert: &XPhyrusAlert) -> Result<()> {
        let alert_json = serde_json::to_string(&serde_json::json!({
            "alert_id": alert.id,
            "alert_type": alert.alert_type.to_string(),
            "severity": alert.severity.to_string(),
            "message": alert.message,
            "component": alert.component,
            "timestamp": alert.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs(),
            "metadata": alert.metadata
        }))
        .context("Failed to serialize alert for command")?;

        let output = tokio::process::Command::new("sh")
            .arg("-c")
            .arg(command)
            .env("QANTO_ALERT_JSON", &alert_json)
            .env("QANTO_ALERT_ID", &alert.id)
            .env("QANTO_ALERT_TYPE", alert.alert_type.to_string())
            .env("QANTO_ALERT_SEVERITY", alert.severity.to_string())
            .env("QANTO_ALERT_MESSAGE", &alert.message)
            .env("QANTO_ALERT_COMPONENT", &alert.component)
            .output()
            .await
            .context("Failed to execute custom notification command")?;

        if output.status.success() {
            debug!("[AlertManager] Custom command notification executed successfully");
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(anyhow::anyhow!(
                "Custom command notification failed with exit code {:?}: {}",
                output.status.code(),
                stderr
            ))
        }
    }

    /// Acknowledge an alert
    pub async fn acknowledge_alert(&self, alert_id: &str) -> Result<()> {
        let mut alerts = self.alerts.write().await;
        if let Some(alert) = alerts.iter_mut().find(|a| a.id == alert_id) {
            alert.acknowledge();
            Ok(())
        } else {
            Err(anyhow::anyhow!("Alert not found: {}", alert_id))
        }
    }

    /// Resolve an alert
    pub async fn resolve_alert(
        &self,
        alert_id: &str,
        resolved_by: impl Into<String>,
        resolution: impl Into<String>,
    ) -> Result<()> {
        let mut alerts = self.alerts.write().await;
        let mut history = self.history.write().await;

        if let Some(index) = alerts.iter().position(|a| a.id == alert_id) {
            let mut alert = alerts.remove(index);
            alert.resolve(resolved_by, resolution);

            // Add to history
            history.push(alert);

            // Trim history if needed
            if history.len() > self.max_history {
                history.remove(0);
            }

            Ok(())
        } else {
            Err(anyhow::anyhow!("Alert not found: {}", alert_id))
        }
    }

    /// Get all active alerts
    pub async fn get_active_alerts(&self) -> Vec<XPhyrusAlert> {
        let alerts = self.alerts.read().await;
        alerts.clone()
    }

    /// Get alert history
    pub async fn get_alert_history(&self) -> Vec<XPhyrusAlert> {
        let history = self.history.read().await;
        history.clone()
    }

    /// Get alerts by type
    pub async fn get_alerts_by_type(&self, alert_type: AlertType) -> Vec<XPhyrusAlert> {
        let alerts = self.alerts.read().await;
        alerts
            .iter()
            .filter(|a| a.alert_type == alert_type)
            .cloned()
            .collect()
    }

    /// Get alerts by severity
    pub async fn get_alerts_by_severity(&self, severity: AlertSeverity) -> Vec<XPhyrusAlert> {
        let alerts = self.alerts.read().await;
        alerts
            .iter()
            .filter(|a| a.severity == severity)
            .cloned()
            .collect()
    }

    /// Get alerts by component
    pub async fn get_alerts_by_component(&self, component: &str) -> Vec<XPhyrusAlert> {
        let alerts = self.alerts.read().await;
        alerts
            .iter()
            .filter(|a| a.component == component)
            .cloned()
            .collect()
    }
}

/// Error types for X-PHYRUS
#[derive(Debug, Error)]
pub enum XPhyrusError {
    /// System entropy error
    #[error("System entropy error: {0}")]
    EntropyError(String),

    /// File integrity error
    #[error("File integrity error: {0}")]
    FileIntegrityError(String),

    /// Port availability error
    #[error("Port availability error: {0}")]
    PortAvailabilityError(String),

    /// Chain state error
    #[error("Chain state error: {0}")]
    ChainStateError(String),

    /// Security threat error
    #[error("Security threat detected: {0}")]
    SecurityThreatError(String),

    /// Runtime integrity error
    #[error("Runtime integrity error: {0}")]
    RuntimeIntegrityError(String),

    /// Deployment error
    #[error("Deployment error: {0}")]
    DeploymentError(String),

    /// Peer connection error
    #[error("Peer connection error: {0}")]
    PeerConnectionError(String),

    /// Quantum security error
    #[error("Quantum security error: {0}")]
    QuantumSecurityError(String),

    /// Cloud provider error
    #[error("Cloud provider error: {0}")]
    CloudProviderError(String),

    /// Transaction trace error
    #[error("Transaction trace error: {0}")]
    TransactionTraceError(String),

    /// Compliance error
    #[error("Compliance error: {0}")]
    ComplianceError(String),

    /// Self-healing error
    #[error("Self-healing error: {0}")]
    SelfHealingError(String),

    /// System error
    #[error("System error: {0}")]
    SystemError(String),
}

/// Global alert manager instance
static ALERT_MANAGER: once_cell::sync::Lazy<AlertManager> =
    once_cell::sync::Lazy::new(AlertManager::new);

/// Add missing dependency
use once_cell;

/// Get the global alert manager instance
pub fn alert_manager() -> &'static AlertManager {
    &ALERT_MANAGER
}

// --- Primary Public Interface ---
/// Initializes the X-PHYRUS™ Protocol Stack, performing a comprehensive suite of
/// pre-boot diagnostics and activating advanced security and operational protocols.
/// This function is the first line of defense and readiness for the Qanto node.
pub async fn initialize_pre_boot_sequence(config: &Config, wallet_path: &Path) -> Result<()> {
    info!("[X-PHYRUS]™ Protocol Stack Activated. Running pre-boot diagnostics...");
    init_zero_hang_bootloader(config, wallet_path)
        .await
        .context("Zero-Hang™ Bootloader check failed")?;
    launch_deepcore_sentinel()
        .await
        .context("DeepCore Sentinel™ activation failed")?;
    init_extended_protocols(config).await?;
    info!("[X-PHYRUS]™ All pre-boot checks passed. System is nominal. Handing off to main node process.");
    Ok(())
}

// --- ⚡ 1. Zero-Hang™ Bootloader ---
/// Performs critical pre-flight checks on system entropy, file permissions, and chain state integrity to eliminate common startup hangs.
async fn init_zero_hang_bootloader(config: &Config, wallet_path: &Path) -> Result<()> {
    info!("[X-PHYRUS::Zero-Hang™] Launching Node Integrity Precheck...");
    check_system_entropy()?;
    check_file_integrity(wallet_path).await?;
    check_port_availability(config).await?;
    check_chain_state_integrity().await?;
    info!("[X-PHYRUS::Zero-Hang™] Node integrity checks completed successfully.");
    Ok(())
}

/// Verifies the system's cryptographic entropy pool.
/// Sophistication: Beyond just checking responsiveness, this could involve statistical
/// tests (e.g., NIST SP 800-22) on initial entropy samples to ensure sufficient quality
/// for post-quantum cryptographic operations.
fn check_system_entropy() -> Result<()> {
    debug!("[X-PHYRUS::Zero-Hang™] Checking system entropy pool...");
    let mut buf = [0u8; 32];

    match getrandom::getrandom(&mut buf) {
        Ok(_) => {
            // Advanced: (Conceptual) Perform a basic statistical test for randomness,
            // like counting transitions or runs. A real implementation would use a robust test suite.
            let zero_count = buf.iter().filter(|&&b| b == 0).count();
            if !(2..=16).contains(&zero_count) {
                let mut message = String::with_capacity(100);
                message.push_str("Entropy sample seems biased (");
                message.push_str(&zero_count.to_string());
                message.push_str(" zeros out of 32). Consider external entropy sources.");

                let alert = XPhyrusAlert::new(
                    AlertType::EntropyAlert,
                    AlertSeverity::Warning,
                    message,
                    "Zero-Hang Bootloader",
                )
                .with_metadata("zero_count", zero_count.to_string())
                .with_metadata("sample_size", "32")
                .with_metadata("expected_range", "2-16");

                tokio::spawn(async move {
                    alert_manager().add_alert(alert).await;
                });
            }

            let alert = XPhyrusAlert::new(
                AlertType::EntropyAlert,
                AlertSeverity::Info,
                "Entropy pool is responsive and operational",
                "Zero-Hang Bootloader",
            )
            .with_metadata("entropy_bytes", "32")
            .with_metadata("status", "healthy");

            tokio::spawn(async move {
                alert_manager().add_alert(alert).await;
            });

            info!("[OK] Entropy pool is responsive.");
            Ok(())
        }
        Err(e) => {
            let alert = XPhyrusAlert::new(
                AlertType::EntropyAlert,
                AlertSeverity::Critical,
                "OS entropy pool non-responsive. System cannot generate secure cryptographic data. This can cause the node to hang indefinitely. Install an entropy-gathering daemon like 'haveged' and restart.",
                "Zero-Hang Bootloader"
            )
            .with_metadata("error", e.to_string())
            .with_metadata("recommendation", "Install entropy daemon like 'haveged'");

            tokio::spawn(async move {
                alert_manager().add_alert(alert).await;
            });

            Err(anyhow::anyhow!(
                "FATAL: OS entropy pool non-responsive: {}",
                e
            ))
        }
    }
}

/// Verifies the cryptographic integrity and permissions of critical files (e.g., wallet, config).
/// Sophistication: Uses cryptographic hashing to detect tampering and enforces strict UNIX-like
/// file permissions for sensitive data. Could integrate a blockchain-based immutable ledger
/// for tracking file hash histories.
async fn check_file_integrity(wallet_path: &Path) -> Result<()> {
    debug!("[X-PHYRUS::Zero-Hang™] Verifying critical file paths and cryptographic integrity...");

    // Check wallet file existence and permissions
    let wallet_metadata = match fs::metadata(wallet_path).await {
        Ok(metadata) => metadata,
        Err(e) => {
            let alert = XPhyrusAlert::new(
                AlertType::FileIntegrityAlert,
                AlertSeverity::Critical,
                format!(
                    "Wallet file not found at '{}'. Halting startup.",
                    wallet_path.display()
                ),
                "Zero-Hang Bootloader",
            )
            .with_metadata("file_path", wallet_path.display().to_string())
            .with_metadata("error", e.to_string())
            .with_metadata("operation", "file_metadata_check");

            tokio::spawn(async move {
                alert_manager().add_alert(alert).await;
            });

            return Err(anyhow::anyhow!(
                "FATAL: Wallet file not found at '{}': {}",
                wallet_path.display(),
                e
            ));
        }
    };

    #[cfg(unix)] // Unix-specific permission check for security
    {
        use std::os::unix::fs::PermissionsExt;
        let permissions = wallet_metadata.permissions();
        // Check for 0o600 (owner read/write only)
        if permissions.mode() & 0o177 != 0 {
            // Check if any bits other than owner read/write are set
            let alert = XPhyrusAlert::new(
                AlertType::FileIntegrityAlert,
                AlertSeverity::Warning,
                {
                    let mut message = String::with_capacity(100);
                    message.push_str("Wallet file '");
                    message.push_str(&wallet_path.display().to_string());
                    message.push_str("' has insecure permissions (");
                    message.push_str(&format!("{:o}", permissions.mode() & 0o777));
                    message.push_str("). Recommended: 0o600.");
                    message
                },
                "Zero-Hang Bootloader",
            )
            .with_metadata("file_path", wallet_path.display().to_string())
            .with_metadata("current_permissions", {
                let mut perm_str = String::with_capacity(8);
                perm_str.push_str(&format!("{:o}", permissions.mode() & 0o777));
                perm_str
            })
            .with_metadata("recommended_permissions", "0o600")
            .with_metadata("security_risk", "file_permissions");

            tokio::spawn(async move {
                alert_manager().add_alert(alert).await;
            });

            warn!(
                "[X-PHYRUS::Zero-Hang™] Wallet file '{}' has insecure permissions ({:o}). Recommended: 0o600.",
                wallet_path.display(),
                permissions.mode() & 0o777
            );
            // In a strict mode, this could be an Err. For now, it's a warning.
        }
    }

    // Cryptographic hash check for wallet content (conceptual: to detect external tampering)
    let wallet_content = match fs::read(wallet_path).await {
        Ok(content) => content,
        Err(e) => {
            let alert = XPhyrusAlert::new(
                AlertType::FileIntegrityAlert,
                AlertSeverity::Error,
                format!(
                    "Failed to read wallet file for integrity check: {}",
                    wallet_path.display()
                ),
                "Zero-Hang Bootloader",
            )
            .with_metadata("file_path", wallet_path.display().to_string())
            .with_metadata("error", e.to_string())
            .with_metadata("operation", "file_read");

            tokio::spawn(async move {
                alert_manager().add_alert(alert).await;
            });

            return Err(anyhow::anyhow!("Failed to read wallet file: {}", e));
        }
    };

    let wallet_hash = qanto_hash(&wallet_content);
    let hash_hex = hex::encode(wallet_hash);

    let alert = XPhyrusAlert::new(
        AlertType::FileIntegrityAlert,
        AlertSeverity::Info,
        format!(
            "Wallet file integrity verified successfully: {}",
            wallet_path.display()
        ),
        "Zero-Hang Bootloader",
    )
    .with_metadata("file_path", wallet_path.display().to_string())
    .with_metadata("hash", hash_hex.clone())
    .with_metadata("hash_algorithm", "QantoHash")
    .with_metadata("file_size", wallet_content.len().to_string());

    tokio::spawn(async move {
        alert_manager().add_alert(alert).await;
    });

    debug!("Wallet file cryptographic hash: {hash_hex}"); // Fixed: uninlined_format_args
                                                          // Advanced: Compare this hash against a secure, immutable record (e.g., stored on a distributed ledger).

    info!("[OK] Wallet file is accessible and integrity check passed.");
    Ok(())
}

/// Checks if necessary network ports (API, P2P) are available for binding.
/// Sophistication: Could include a deeper check for network policy conflicts or existing
/// processes listening on ports, providing more actionable error messages.
async fn check_port_availability(config: &Config) -> Result<()> {
    debug!("[X-PHYRUS::Zero-Hang™] Checking network port availability...");

    // Check API Port
    let api_addr: SocketAddr = match config.api_address.parse() {
        Ok(addr) => addr,
        Err(e) => {
            let alert = XPhyrusAlert::new(
                AlertType::PortAvailabilityAlert,
                AlertSeverity::Critical,
                format!("Invalid API address in config: {}", config.api_address),
                "Zero-Hang Bootloader",
            )
            .with_metadata("api_address", config.api_address.clone())
            .with_metadata("error", e.to_string())
            .with_metadata("operation", "address_parsing");

            tokio::spawn(async move {
                alert_manager().add_alert(alert).await;
            });

            return Err(anyhow::anyhow!(
                "Invalid API address in config: {} - {}",
                config.api_address,
                e
            ));
        }
    };

    match TcpListener::bind(api_addr).await {
        Ok(_) => {
            let alert = XPhyrusAlert::new(
                AlertType::PortAvailabilityAlert,
                AlertSeverity::Info,
                format!(
                    "API port {} is available and ready for binding",
                    api_addr.port()
                ),
                "Zero-Hang Bootloader",
            )
            .with_metadata("port", api_addr.port().to_string())
            .with_metadata("address", api_addr.to_string())
            .with_metadata("port_type", "API")
            .with_metadata("status", "available");

            tokio::spawn(async move {
                alert_manager().add_alert(alert).await;
            });

            info!("[OK] API port {} is available.", api_addr.port());
        }
        Err(e) => {
            let alert = XPhyrusAlert::new(
                AlertType::PortAvailabilityAlert,
                AlertSeverity::Critical,
                format!(
                    "API address {api_addr} is already in use or cannot be bound. Halting startup."
                ),
                "Zero-Hang Bootloader",
            )
            .with_metadata("port", api_addr.port().to_string())
            .with_metadata("address", api_addr.to_string())
            .with_metadata("port_type", "API")
            .with_metadata("error", e.to_string())
            .with_metadata("status", "unavailable")
            .with_metadata(
                "recommendation",
                "Check for conflicting processes and restart",
            );

            tokio::spawn(async move {
                alert_manager().add_alert(alert).await;
            });

            error!("FATAL: API address {api_addr} is already in use or cannot be bound: {e}. Halting startup.");
            return Err(anyhow::anyhow!("API address {} unavailable.", api_addr));
        }
    }

    // Check P2P Port
    let p2p_addr_parts: Vec<&str> = config
        .p2p_address
        .trim_start_matches('/')
        .split('/')
        .collect();
    if p2p_addr_parts.len() == 4 && p2p_addr_parts[0] == "ip4" && p2p_addr_parts[2] == "tcp" {
        if let (Ok(ip), Ok(port)) = (
            p2p_addr_parts[1].parse::<std::net::IpAddr>(),
            p2p_addr_parts[3].parse::<u16>(),
        ) {
            let p2p_socket_addr = SocketAddr::new(ip, port);
            match TcpListener::bind(p2p_socket_addr).await {
                Ok(_) => {
                    let alert = XPhyrusAlert::new(
                        AlertType::PortAvailabilityAlert,
                        AlertSeverity::Info,
                        format!(
                            "P2P port {} is available and ready for binding",
                            p2p_socket_addr.port()
                        ),
                        "Zero-Hang Bootloader",
                    )
                    .with_metadata("port", p2p_socket_addr.port().to_string())
                    .with_metadata("address", p2p_socket_addr.to_string())
                    .with_metadata("port_type", "P2P")
                    .with_metadata("status", "available");

                    tokio::spawn(async move {
                        alert_manager().add_alert(alert).await;
                    });

                    info!("[OK] P2P port {} is available.", p2p_socket_addr.port());
                }
                Err(e) => {
                    let alert = XPhyrusAlert::new(
                        AlertType::PortAvailabilityAlert,
                        AlertSeverity::Critical,
                        format!("P2P address {p2p_socket_addr} is already in use or cannot be bound. Halting startup."),
                        "Zero-Hang Bootloader"
                    )
                    .with_metadata("port", p2p_socket_addr.port().to_string())
                    .with_metadata("address", p2p_socket_addr.to_string())
                    .with_metadata("port_type", "P2P")
                    .with_metadata("error", e.to_string())
                    .with_metadata("status", "unavailable")
                    .with_metadata("recommendation", "Check for conflicting processes and restart");

                    tokio::spawn(async move {
                        alert_manager().add_alert(alert).await;
                    });

                    error!("FATAL: P2P address {p2p_socket_addr} is already in use or cannot be bound: {e}. Halting startup.");
                    return Err(anyhow::anyhow!(
                        "P2P address {p2p_socket_addr} unavailable.",
                    ));
                }
            }
        } else {
            let alert = XPhyrusAlert::new(
                AlertType::PortAvailabilityAlert,
                AlertSeverity::Critical,
                format!("Invalid IP or port in P2P address: {}", config.p2p_address),
                "Zero-Hang Bootloader",
            )
            .with_metadata("p2p_address", config.p2p_address.clone())
            .with_metadata("operation", "address_parsing");

            tokio::spawn(async move {
                alert_manager().add_alert(alert).await;
            });

            return Err(anyhow::anyhow!(
                "Invalid IP or port in P2P address: {}",
                config.p2p_address
            ));
        }
    } else {
        let alert = XPhyrusAlert::new(
            AlertType::PortAvailabilityAlert,
            AlertSeverity::Warning,
            "Could not resolve P2P multiaddress to a specific TCP port for pre-checking. Assuming it's valid.",
            "Zero-Hang Bootloader"
        )
        .with_metadata("p2p_multiaddr", config.p2p_address.clone())
        .with_metadata("operation", "multiaddr_resolution")
        .with_metadata("status", "unresolved");

        tokio::spawn(async move {
            alert_manager().add_alert(alert).await;
        });

        warn!("[Warning] Could not resolve P2P multiaddress to a specific TCP port for pre-checking. Assuming it's valid.");
    }

    Ok(())
}

/// Verifies the integrity and accessibility of the chain state database.
/// Sophistication: Beyond read-only open, could perform a lightweight consistency check
/// (e.g., verify genesis block, latest block index, or a few random block lookups)
/// to detect deeper corruption before full node operation.
async fn check_chain_state_integrity() -> Result<()> {
    debug!("[X-PHYRUS::Zero-Hang™] Checking chain state integrity...");
    const DB_PATH: &str = "qantodag_db_evolved";

    if !Path::new(DB_PATH).exists() {
        let alert = XPhyrusAlert::new(
            AlertType::ChainStateAlert,
            AlertSeverity::Info,
            format!("Chain state DB not found at '{DB_PATH}'. This is normal for a first run."),
            "Zero-Hang Bootloader",
        )
        .with_metadata("db_path", DB_PATH)
        .with_metadata("status", "not_found")
        .with_metadata("first_run", "true");

        tokio::spawn(async move {
            alert_manager().add_alert(alert).await;
        });

        warn!("[INFO] Chain state DB not found at '{DB_PATH}'. This is normal for a first run.");
        return Ok(());
    }

    let alert = XPhyrusAlert::new(
        AlertType::ChainStateAlert,
        AlertSeverity::Info,
        format!("Found existing database at '{DB_PATH}'. Attempting to open read-only to verify integrity..."),
        "Zero-Hang Bootloader"
    )
    .with_metadata("db_path", DB_PATH)
    .with_metadata("status", "found")
    .with_metadata("operation", "integrity_check");

    tokio::spawn(async move {
        alert_manager().add_alert(alert).await;
    });

    info!("[INFO] Found existing database at '{DB_PATH}'. Attempting to open read-only to verify integrity...");
    let storage_config = StorageConfig {
        data_dir: PathBuf::from(DB_PATH),
        max_file_size: 64 * 1024 * 1024, // 64MB
        cache_size: 1024 * 1024,         // 1MB
        compression_enabled: true,
        encryption_enabled: false,
        wal_enabled: true,
        sync_writes: true,
        compaction_threshold: 0.7,
        max_open_files: 1000,
    };
    match QantoStorage::new(storage_config) {
        Ok(storage) => {
            // Advanced: (Conceptual) Perform a lightweight consistency check
            // For example, try to retrieve the genesis block.
            if let Ok(Some(_genesis_block_bytes)) = storage.get(b"genesis_block_id") {
                // Assuming a key for genesis block
                let alert = XPhyrusAlert::new(
                    AlertType::ChainStateAlert,
                    AlertSeverity::Info,
                    "Successfully retrieved genesis block ID from DB. Chain state integrity verified.".to_string(),
                    "Zero-Hang Bootloader"
                )
                .with_metadata("db_path", DB_PATH)
                .with_metadata("status", "genesis_verified")
                .with_metadata("operation", "genesis_block_check")
                .with_metadata("integrity_status", "complete");

                tokio::spawn(async move {
                    alert_manager().add_alert(alert).await;
                });

                debug!("Successfully retrieved genesis block ID from DB.");
            } else {
                let alert = XPhyrusAlert::new(
                    AlertType::ChainStateAlert,
                    AlertSeverity::Warning,
                    "Could not verify genesis block in DB. Possible partial corruption or unusual state.".to_string(),
                    "Zero-Hang Bootloader"
                )
                .with_metadata("db_path", DB_PATH)
                .with_metadata("status", "genesis_missing")
                .with_metadata("operation", "genesis_block_check")
                .with_metadata("integrity_status", "partial")
                .with_metadata("recommendation", "Monitor for additional corruption signs during runtime");

                tokio::spawn(async move {
                    alert_manager().add_alert(alert).await;
                });

                warn!("[X-PHYRUS::Zero-Hang™] Could not verify genesis block in DB. Possible partial corruption or unusual state.");
            }

            let alert = XPhyrusAlert::new(
                AlertType::ChainStateAlert,
                AlertSeverity::Info,
                "Chain state database opened successfully. Integrity check passed.".to_string(),
                "Zero-Hang Bootloader",
            )
            .with_metadata("db_path", DB_PATH)
            .with_metadata("status", "success")
            .with_metadata("operation", "read_only_open")
            .with_metadata("integrity_status", "verified");

            tokio::spawn(async move {
                alert_manager().add_alert(alert).await;
            });

            info!("[OK] Chain state database opened successfully. Integrity check passed.");
            Ok(())
        }
        Err(e) => {
            let alert = XPhyrusAlert::new(
                AlertType::ChainStateAlert,
                AlertSeverity::Critical,
                format!("Could not open existing chain state database: {e}. The database may be corrupt or locked by another process."),
                "Zero-Hang Bootloader"
            )
            .with_metadata("db_path", DB_PATH)
            .with_metadata("status", "failure")
            .with_metadata("operation", "read_only_open")
            .with_metadata("error", e.to_string())
            .with_metadata("integrity_status", "compromised")
            .with_metadata("recommendation", "Database may be corrupted or locked. Check for other processes and consider backup restoration.");

            tokio::spawn(async move {
                alert_manager().add_alert(alert).await;
            });

            error!("FATAL: Could not open existing chain state database: {e}. The database may be corrupt or locked by another process. Please resolve the issue before restarting. Halting startup.");
            Err(anyhow::anyhow!(
                "Chain state DB at '{}' is inaccessible or corrupt: {}",
                DB_PATH,
                e
            ))
        }
    }
}

// --- 💣 2. DeepCore Sentinel™ ---
/// Conducts an initial system security scan to detect known Advanced Persistent Threat (APT) toolchains and other high-risk system vulnerabilities.
async fn launch_deepcore_sentinel() -> Result<()> {
    send_initialization_alert().await;
    info!("[X-PHYRUS::DeepCore™] Activating DeepCore Sentinel for initial system security scan...");

    scan_for_apt_toolchains().await?;
    start_continuous_monitoring();
    send_completion_alert().await;

    info!("[X-PHYRUS::DeepCore™] Initial security scan complete. No immediate threats detected.");
    Ok(())
}

/// Send initialization alert for DeepCore Sentinel
async fn send_initialization_alert() {
    let alert = XPhyrusAlert::new(
        AlertType::SystemAlert,
        AlertSeverity::Info,
        "Activating DeepCore Sentinel™ for initial system security scan...".to_string(),
        "DeepCore Sentinel",
    )
    .with_metadata("component", "deepcore_sentinel")
    .with_metadata("status", "initializing")
    .with_metadata("operation", "security_scan_start");

    tokio::spawn(async move {
        alert_manager().add_alert(alert).await;
    });
}

/// Start continuous runtime integrity monitoring
fn start_continuous_monitoring() {
    task::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(300)).await; // Scan every 5 minutes
            if let Err(e) = perform_runtime_integrity_scan().await {
                handle_integrity_scan_failure(e).await;
            }
        }
    });
}

/// Handle runtime integrity scan failure
async fn handle_integrity_scan_failure(error: anyhow::Error) {
    let alert = XPhyrusAlert::new(
        AlertType::RuntimeIntegrityAlert,
        AlertSeverity::Error,
        format!("Runtime integrity check failed: {error:?}"),
        "DeepCore Sentinel",
    )
    .with_metadata("component", "runtime_scanner")
    .with_metadata("status", "failure")
    .with_metadata("operation", "integrity_scan")
    .with_metadata("error", error.to_string())
    .with_metadata("scan_interval", "300s")
    .with_metadata(
        "recommendation",
        "Investigate potential security compromise or system corruption",
    );

    alert_manager().add_alert(alert).await;
    error!("[DeepCore::RuntimeScan] Runtime integrity check failed: {error:?}");
}

/// Send completion alert for DeepCore Sentinel
async fn send_completion_alert() {
    let alert = XPhyrusAlert::new(
        AlertType::SystemAlert,
        AlertSeverity::Info,
        "Initial security scan complete. No immediate threats detected.".to_string(),
        "DeepCore Sentinel",
    )
    .with_metadata("component", "deepcore_sentinel")
    .with_metadata("status", "active")
    .with_metadata("operation", "security_scan_complete")
    .with_metadata("threat_level", "none")
    .with_metadata("monitoring_enabled", "true");

    tokio::spawn(async move {
        alert_manager().add_alert(alert).await;
    });
}

/// (Conceptual) Performs a sophisticated runtime integrity scan, looking for kernel-level
/// tampering, rootkits, and anomalous process behavior.
async fn perform_runtime_integrity_scan() -> Result<()> {
    debug!("[X-PHYRUS::DeepCore™] Performing deep runtime integrity scan...");

    send_runtime_scan_initiation_alert().await;

    let entropy_check_passed = perform_entropy_check()?;

    if !entropy_check_passed {
        handle_runtime_anomaly_detected().await;
    } else {
        handle_runtime_scan_success().await;
    }

    Ok(())
}

/// Sends an alert indicating that runtime integrity scanning has been initiated.
async fn send_runtime_scan_initiation_alert() {
    let init_alert = XPhyrusAlert::new(
        AlertType::RuntimeIntegrityAlert,
        AlertSeverity::Info,
        "Runtime integrity scan initiated",
        "DeepCore Sentinel",
    )
    .with_metadata("operation", "runtime_integrity_scan")
    .with_metadata("status", "scanning")
    .with_metadata("scan_type", "comprehensive");

    tokio::spawn(async move {
        alert_manager().add_alert(init_alert).await;
    });
}

/// Performs entropy check as part of runtime integrity scan.
/// Conceptual:
/// 1. Hook into OS APIs for loaded kernel modules and check against known good hashes.
/// 2. Scan for unexpected open network sockets or listening ports.
/// 3. Analyze process memory for injected code or unexpected modifications.
/// 4. Monitor CPU/memory usage patterns for cryptographic operations indicative of hidden mining or data exfiltration.
/// 5. Integrate with a behavioral anomaly detection engine.
fn perform_entropy_check() -> Result<bool> {
    // Simulate a complex check
    let entropy_check_passed = SystemTime::now()
        .duration_since(UNIX_EPOCH)?
        .as_secs()
        .is_multiple_of(2); // Just an arbitrary check

    Ok(entropy_check_passed)
}

/// Handles the case when a runtime anomaly is detected.
async fn handle_runtime_anomaly_detected() {
    warn!("[DeepCore::RuntimeScan] Minor behavioral anomaly detected (conceptual).");

    let anomaly_alert = XPhyrusAlert::new(
        AlertType::RuntimeIntegrityAlert,
        AlertSeverity::Warning,
        "Behavioral anomaly detected during runtime integrity scan",
        "DeepCore Sentinel",
    )
    .with_metadata("anomaly_type", "behavioral")
    .with_metadata("severity_level", "minor")
    .with_metadata("scan_result", "anomaly_detected")
    .with_metadata(
        "recommendation",
        "Continue monitoring for additional anomalies",
    );

    tokio::spawn(async move {
        alert_manager().add_alert(anomaly_alert).await;
    });
}

/// Handles the case when runtime integrity scan completes successfully.
async fn handle_runtime_scan_success() {
    let success_alert = XPhyrusAlert::new(
        AlertType::RuntimeIntegrityAlert,
        AlertSeverity::Info,
        "Runtime integrity scan completed successfully",
        "DeepCore Sentinel",
    )
    .with_metadata("scan_result", "clean")
    .with_metadata("threat_level", "none")
    .with_metadata("status", "completed");

    tokio::spawn(async move {
        alert_manager().add_alert(success_alert).await;
    });
}

/// Scans the system for indicators of compromise, known APT toolchains, and rootkits.
/// Sophistication: Beyond static binary checks, this would involve behavioral analysis
/// of running processes, network traffic patterns, and hooks into OS security APIs.
async fn scan_for_apt_toolchains() -> Result<()> {
    debug!("[X-PHYRUS::DeepCore™] Scanning for known APT toolchains and attack vectors...");

    send_apt_scan_initiation_alert().await;

    let detected_suspicious_tools = scan_for_suspicious_binaries().await;

    if !detected_suspicious_tools.is_empty() {
        handle_suspicious_tools_detected(&detected_suspicious_tools).await;
    } else {
        handle_clean_scan_result().await;
    }

    Ok(())
}

/// Sends an alert indicating that APT toolchain scanning has been initiated.
async fn send_apt_scan_initiation_alert() {
    let init_alert = XPhyrusAlert::new(
        AlertType::SecurityThreatAlert,
        AlertSeverity::Info,
        "APT toolchain scan initiated",
        "DeepCore Sentinel",
    )
    .with_metadata("operation", "apt_toolchain_scan")
    .with_metadata("status", "scanning")
    .with_metadata("scan_type", "apt_detection");

    tokio::spawn(async move {
        alert_manager().add_alert(init_alert).await;
    });
}

/// Scans for suspicious binaries that could be used in APT attacks.
async fn scan_for_suspicious_binaries() -> Vec<&'static str> {
    let suspicious_bins = [
        "/usr/bin/osascript",    // Common macOS scripting tool, can be abused
        "/usr/bin/plutil",       // macOS property list utility, can be abused
        "/usr/bin/codesign",     // macOS code signing, can be abused
        "/usr/bin/launchctl",    // macOS service management, can be abused for persistence
        "/usr/local/bin/netcat", // Common utility, often used by attackers
        "/usr/bin/nmap",         // Network scanner, often used by attackers
                                 // Add more platform-specific or common attack tools
    ];
    let mut detected_suspicious_tools = Vec::new();

    for path_str in suspicious_bins.iter() {
        if fs::metadata(path_str).await.is_ok() {
            detected_suspicious_tools.push(*path_str);
            debug!("[DeepCore] Verified presence of standard system tool: {path_str}. This tool can be abused in state-sponsored attacks.");
        }
    }

    detected_suspicious_tools
}

/// Handles the case when suspicious tools are detected on the system.
async fn handle_suspicious_tools_detected(detected_tools: &[&str]) {
    warn!(
        "[X-PHYRUS::DeepCore™] Detected potentially suspicious tools: {detected_tools:?}. These are legitimate tools but can be indicators of APT presence if found in unexpected environments or used maliciously."
    ); // Fixed: uninlined_format_args
       // Advanced: Trigger an alert to a security operations center (SOC) or block network access.

    let tools_str = detected_tools.join(", ");
    let threat_alert = XPhyrusAlert::new(
        AlertType::SecurityThreatAlert,
        AlertSeverity::Warning,
        "Potentially suspicious tools detected on system",
        "DeepCore Sentinel",
    )
    .with_metadata("detected_tools", &tools_str)
    .with_metadata("tool_count", detected_tools.len().to_string())
    .with_metadata("threat_level", "moderate")
    .with_metadata(
        "recommendation",
        "Monitor for malicious usage patterns and verify legitimate use",
    );

    tokio::spawn(async move {
        alert_manager().add_alert(threat_alert).await;
    });
}

/// Handles the case when no suspicious tools are detected (clean scan result).
async fn handle_clean_scan_result() {
    info!("[OK] No high-risk binaries or active exploit patterns found.");

    let clean_alert = XPhyrusAlert::new(
        AlertType::SecurityThreatAlert,
        AlertSeverity::Info,
        "APT toolchain scan completed - no threats detected",
        "DeepCore Sentinel",
    )
    .with_metadata("scan_result", "clean")
    .with_metadata("threat_level", "none")
    .with_metadata("status", "completed");

    tokio::spawn(async move {
        alert_manager().add_alert(clean_alert).await;
    });
}

// --- ⚙️ 3. Extended Protocol Initialization ---
/// Initializes a suite of advanced, security-focused and cloud-adaptive protocols.
async fn init_extended_protocols(config: &Config) -> Result<()> {
    info!("[X-PHYRUS] Initializing extended protocol suite...");
    init_hydra_deploy().await?;
    init_peer_flash(config).await?;
    init_quantum_shield(config).await?;
    init_cloud_anchor().await?;
    init_phase_trace().await?;
    init_traceforce_x().await?;
    // New: Auto-healing protocol (conceptual)
    init_auto_heal_protocols().await?;
    info!("[X-PHYRUS] Extended protocol suite is standing by.");
    Ok(())
}

/// Automatically detects multi-node deployment manifests (hydra_manifest.toml) to activate specialized coordination and scaling logic.
/// Sophistication: Reads a manifest for dynamic deployment, potentially integrating with
/// cloud-native orchestration platforms (Kubernetes, generic container orchestration) through a secure,
/// attested channel.
async fn init_hydra_deploy() -> Result<()> {
    match fs::read_to_string("hydra_manifest.toml").await {
        Ok(manifest) => {
            let peer_count = manifest
                .lines()
                .filter(|l| l.starts_with("peer_address"))
                .count();
            info!("[X-PHYRUS::HydraDeploy™] Deployment manifest found, configuring for {peer_count} nodes. Multi-node deployment logic is ACTIVE.");
            // Advanced: (Conceptual) Parse manifest, dynamically provision resources,
            // establish secure, attested TLS channels between new nodes and an orchestrator.
            // Eg: verify manifest signature, attest cloud instance identity.
            debug!("HydraDeploy is orchestrating {peer_count} nodes."); // Fixed: uninlined_format_args
        }
        Err(_) => {
            info!("[X-PHYRUS::HydraDeploy™] No deployment manifest. Multi-node deployment logic standing by.");
        }
    }
    Ok(())
}

/// Activates an advanced peer discovery overlay when a priority peer list is provided in the configuration, ensuring robust network connectivity.
/// Sophistication: Integrates SAGA's reputation data to prioritize trustworthy peers,
/// uses hybrid key exchange (e.g., X25519 + Kyber) for initial handshake, and validates
/// PQC certificates for mutual authentication.
async fn init_peer_flash(config: &Config) -> Result<()> {
    if !config.peers.is_empty() {
        info!("[X-PHYRUS::PeerFlash™] Priority peer list found in config.toml. Advanced peer discovery overlay is ACTIVE.");
        // Advanced: (Conceptual)
        // 1. Load PQC root certificates for trusted peer authorities. (e.g., from a secure, immutable storage)
        // 2. Perform hybrid key exchange during libp2p handshake (e.g., KEM: Kyber, Signature: Dilithium).
        // 3. Authenticate peers using PQC certificates (e.g., Dilithium-signed certs validated against PQC CAs).
        // 4. Dynamically adjust peer connections based on network load, latency, and SAGA reputation.
        debug!(
            "PeerFlash initialized with {} configured peers.",
            config.peers.len()
        ); // Fixed: uninlined_format_args
    } else {
        info!("[X-PHYRUS::PeerFlash™] Advanced peer discovery overlay standing by.");
    }
    Ok(())
}

/// Engages enhanced cryptographic validation protocols when ZK-proofs are enabled, providing a firewall layer against quantum computing threats.
/// Sophistication: Beyond ZK-proofs, this involves PQC key encapsulation (Kyber),
/// authenticated key exchange, and continuous monitoring for quantum-based attacks
/// or side-channel leakage.
async fn init_quantum_shield(config: &Config) -> Result<()> {
    if config.zk_enabled {
        info!("[X-PHYRUS::QuantumShield™] ZK-proofs enabled. Activating enhanced cryptographic validation protocols. Quantum-resistant firewall layer is ACTIVE.");
        // Advanced: (Conceptual)
        // 1. Initialize PQC KEM (e.g., Kyber) for all new session keys. This uses SystemTime/UNIX_EPOCH
        //    for a conceptual "nonce" or random seed generation in a more complex setup.
        let pqc_seed = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        debug!("Conceptual PQC KEM initialized with time-based seed: {pqc_seed}"); // Fixed: uninlined_format_args

        // 2. Implement a hybrid TLS/Noise handshake using both classical (e.g., ECDH) and PQC KEM.
        debug!("Conceptual Hybrid TLS/Noise handshake active (classical + PQC KEM).");

        // 3. Activate a "quantum-resistant firewall" that inspects network flows for patterns
        //    indicative of quantum-accelerated attacks (e.g., unusual computational demands
        //    for specific cryptographic primitives, side-channel analysis detection).
        debug!("Conceptual Quantum-Resistant Firewall active.");

        // 4. Secure boot with PQC-signed firmware updates.
        debug!("Conceptual PQC-signed firmware validation enabled at boot.");
    } else {
        info!("[X-PHYRUS::QuantumShield™] Using standard lattice-based signatures. Quantum-resistant firewall layer is standing by.");
    }
    Ok(())
}

/// Detects cloud provider environments (GCP, Azure) to enable cloud-native elastic mining and scaling capabilities.
/// Sophistication: Integrates with cloud provider APIs (GCP, Azure) to dynamically
/// adjust node resources (CPU, RAM, network I/O) based on network demand, shard load,
/// and economic incentives from SAGA. Supports auto-scaling and multi-region deployment.
async fn init_cloud_anchor() -> Result<()> {
    let detected_cloud_env = detect_cloud_environment();

    if let Some(cloud_name) = detected_cloud_env {
        handle_cloud_detected(cloud_name);
    } else {
        handle_no_cloud_detected();
    }

    Ok(())
}

fn detect_cloud_environment() -> Option<&'static str> {
    let cloud_vars = [
        // Removed AWS detection for NameCheap hosting migration
        ("GOOGLE_CLOUD_PROJECT", "Google Cloud Platform"),
        ("AZURE_FUNCTIONS_ENVIRONMENT", "Azure"),
        // Add more cloud providers
    ];

    for (var, name) in cloud_vars.iter() {
        if env::var(var).is_ok() {
            return Some(name);
        }
    }

    None
}

fn handle_cloud_detected(cloud_name: &str) {
    info!("[X-PHYRUS::CloudAnchor™] Cloud provider detected: {cloud_name}. Cloud-native elastic mining logic is ACTIVE.");
    // Advanced: (Conceptual)
    // 1. Authenticate with cloud provider APIs using federated identity or secure tokens.
    // 2. Register node for dynamic resource scaling (e.g., automatically request more CPU/RAM based on mempool size or block validation queue depth).
    // 3. Implement geo-aware sharding: prioritize connection to or mining on shards in nearby data centers to reduce latency.
    // 4. Integrate with cloud-specific auto-scaling groups for node self-healing/replication (e.g., provision new instances if current one is unhealthy).
    debug!("CloudAnchor configured for {cloud_name}.");
}

fn handle_no_cloud_detected() {
    info!("[X-PHYRUS::CloudAnchor™] Cloud-native mining logic standing by.");
}

/// Verifies the database backend to enable a traceable block propagation graph for enhanced auditability.
/// Sophistication: Beyond simple metadata check, this initiates a connection to a distributed
/// graph database (e.g., Dgraph, Neo4j) to store and query block propagation paths, latency,
/// and anomaly events for forensic analysis and real-time visualization.
async fn init_phase_trace() -> Result<()> {
    if fs::metadata("./qantodag_db_evolved/CURRENT").await.is_ok() {
        info!("[X-PHYRUS::PhaseTrace™] DB backend verified. Traceable block propagation graph is ACTIVE.");
        // Advanced: (Conceptual)
        // 1. Establish connection to a distributed graph database (e.g., via a gRPC client).
        // 2. Initialize schema for block propagation events (miner, timestamp, parents, children, network_latency, anomaly_flags).
        // 3. Start a background task to stream block propagation data to the graph DB for real-time analysis and anomaly visualization.
        debug!("PhaseTrace module is now tracing block propagation events.");
    } else {
        info!("[X-PHYRUS::PhaseTrace™] DB backend not found. Traceability will activate on first write.");
    }
    Ok(())
}

/// Activates a governance and compliance tracing stack when a traceforce_watchlist.csv file is present, ensuring regulatory adherence.
/// Sophistication: Dynamically loads policy rules (e.g., from a smart contract),
/// uses ZK-SNARKs for privacy-preserving attestations of compliance (e.g., proving
/// a transaction is on a watchlist without revealing the transaction details).
async fn init_traceforce_x() -> Result<()> {
    match fs::read_to_string("traceforce_watchlist.csv").await {
        Ok(watchlist) => {
            let watch_count = watchlist.lines().count();
            info!("[X-PHYRUS::TraceForce-X™] Compliance watchlist found with {watch_count} entries. Governance and compliance tracing stack is ACTIVE.");
            // Advanced: (Conceptual)
            // 1. Parse watchlist and load into an in-memory, cryptographically hashed structure (e.g., a Merkle tree of watchlisted entities).
            // 2. Integrate with SAGA's governance module for automated policy enforcement based on watchlist hits (e.g., proposing slashing for interactions with blacklisted addresses).
            // 3. Implement ZK-proof generation for privacy-preserving compliance attestations (e.g., "prove I am NOT on watchlist X without revealing my identity").
            debug!("TraceForce-X initialized with {watch_count} watchlist entries.");
            // Fixed: uninlined_format_args
        }
        Err(_) => {
            info!("[X-PHYRUS::TraceForce-X™] No compliance watchlist. Governance and compliance tracing stack standing by.");
        }
    }
    Ok(())
}

/// New: Initializes auto-healing protocols for robust node operation.
/// Sophistication: Monitors critical node metrics (CPU, memory, disk I/O, network connectivity,
/// internal component health) and triggers automated self-repair mechanisms
/// (e.g., restart modules, clean cache, resync from trusted peers, orchestrate
/// cloud provider healing actions). Integrates with DeepCore Sentinel for threat-aware healing.
async fn init_auto_heal_protocols() -> Result<()> {
    info!("[X-PHYRUS::AutoHeal™] Activating self-healing and fault-recovery protocols...");
    // Advanced: (Conceptual)
    // 1. Register health probes for all internal components (DAG, Mempool, P2P, SAGA) with a central health monitoring service.
    // 2. Implement a state machine for recovery:
    //    - Minor issues (e.g., a single P2P connection drops): attempt re-establishing, clear transient caches.
    //    - Moderate issues (e.g., mempool is constantly full or high transaction validation failure rate): restart mempool module, resync blockchain state from trusted peers.
    //    - Critical issues (e.g., database corruption, consistent crashes): trigger cloud provider auto-healing/replacement actions (if CloudAnchor active) or initiate a full node rebuild.
    // 3. Integrate with DeepCore Sentinel: if a threat is detected (e.g., rootkit), prioritize forensic data capture and isolation before attempting any healing action to prevent spread.
    // 4. Implement a "quarantine" state for misbehaving components: temporarily disable them and alert operators.
    info!(
        "[X-PHYRUS::AutoHeal™] Self-healing protocols are ACTIVE. Monitoring critical node health."
    ); // Fixed: uninlined_format_args
    Ok(())
}

// --- Utility Functions ---
